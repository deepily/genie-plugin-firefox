# Browser Plugin Authentication Design

**Date**: 2025.07.06  
**Purpose**: Design authentication system for Firefox plugin to integrate with Lupin FastAPI server  
**Status**: Design Phase  

## Background & Problem Statement

The Firefox browser plugin currently lacks proper authentication integration with the Lupin FastAPI server. This creates several issues:

1. **WebSocket ID Requirement**: Agent mode requests require a websocket_id parameter for queue tracking
2. **Session Management**: No persistent session state across plugin lifecycle events
3. **Authentication Timing**: Unclear when and how the plugin should authenticate
4. **State Synchronization**: Multiple plugin components need coordinated auth state

### Current Architecture Gap

- **Lupin GUI**: Single session, authenticates on startup, maintains WebSocket connection
- **Browser Plugin**: Multiple ephemeral components, no persistent connection, HTTP-only requests
- **Server Expectation**: All agent requests need websocket_id for TodoFifoQueue.push_job()

## Architecture Overview

### Recommended Approach: Lazy Authentication with Background Script Caching

**Core Principle**: Authenticate only when needed, cache persistently, coordinate across components

### Component Responsibilities

1. **Background Script** (`background.js`)
   - **Auth State Manager**: Single source of truth for authentication
   - **Token Storage**: Persistent storage using `browser.storage.local`
   - **Session Management**: Handle token refresh and re-authentication
   - **API Gateway**: Proxy authenticated requests for other components

2. **Popup/Recorder** (`recorder.js`)
   - **Auth Consumer**: Request auth state from background script
   - **User Interaction**: Display auth status, handle auth failures
   - **API Requests**: Use background script for all authenticated calls

3. **Content Scripts** (`content.js`)
   - **Minimal Auth**: Only request auth when needed for content features
   - **Background Communication**: Route through background script for consistency

4. **Sidebar** (`sidebar.html`)
   - **Auth Status Display**: Show connection status and user info
   - **Manual Auth**: Allow user to manually trigger re-authentication

## Authentication Flow

### Initial Authentication Flow

```
1. User clicks record button
2. Recorder → Background: "Need authenticated session"
3. Background checks browser.storage.local for valid session
4. IF no valid session:
   a. Background → FastAPI: POST /api/get-session-id
   b. Background stores session_id and tokens
   c. Background → Recorder: "Session ready"
5. Recorder → Background: "Make authenticated API call"
6. Background adds session_id and headers
7. Background → FastAPI: POST /api/upload-and-transcribe-mp3?session_id=xxx
8. Background → Recorder: Return response
```

### Re-authentication Flow

```
1. Background detects expired/invalid token
2. Background clears stored auth state
3. Background triggers fresh authentication
4. Background notifies all components of auth state change
5. Components retry failed requests
```

### Error Handling Flow

```
1. API call returns 401/403
2. Background marks session as invalid
3. Background attempts re-authentication
4. IF re-auth fails:
   a. Background notifies user via popup
   b. Background clears all auth state
   c. User must manually retry operation
```

## Implementation Phases

### Phase 1: Background Script Authentication Manager
**Goal**: Create centralized auth service in background script

#### Phase 1A: Pure JavaScript Development ✅ **COMPLETED**
**Goal**: Build core AuthManager logic with full test coverage in pure JS environment

**Architecture**: Dependency injection pattern for maximum testability
- AuthManager class with injected dependencies (storage, messaging, timer, API)
- Mock implementations for all browser APIs
- Interface-based design for easy browser integration later

**Tasks**: ✅ **ALL COMPLETED**
- ✅ Set up Jest testing infrastructure with coverage reporting
- ✅ Create AuthManager class with dependency injection architecture
- ✅ Implement mock classes for browser APIs (storage, messaging, timers)
- ✅ Build session management logic (create, validate, refresh, destroy)
- ✅ Add comprehensive error handling with custom error classes
- ✅ Write complete test suite for all core functionality
- ✅ Create storage and messaging abstraction interfaces
- ✅ Create authentication factory for easy initialization
- ✅ Document API contracts and usage patterns

**File Structure**: ✅ **IMPLEMENTED**
```
js/auth/
├── auth-manager.js           # ✅ Core AuthManager class
├── auth-factory.js           # ✅ Factory for easy initialization  
├── storage-interface.js      # ✅ Storage abstraction
├── messaging-interface.js    # ✅ Messaging abstraction  
├── session-validator.js     # ✅ Session validation logic
├── auth-errors.js           # ✅ Custom error classes
└── mocks/
    ├── mock-storage.js       # ✅ Testing storage mock
    ├── mock-messaging.js     # ✅ Testing messaging mock
    └── mock-server-api.js    # ✅ Testing API mock

test/
└── auth-manager.test.js      # ✅ Comprehensive test suite (80%+ coverage)
```

**Deliverables**: ✅ **ALL COMPLETED**
- ✅ Complete AuthManager class with dependency injection
- ✅ Authentication factory for easy browser integration
- ✅ Full mock implementation suite for testing
- ✅ Comprehensive test suite with 80%+ coverage
- ✅ Documented interfaces for browser integration
- ✅ Jest-compatible testing infrastructure

**Tests**: ✅ **ALL IMPLEMENTED**
- ✅ Session lifecycle management (create, validate, refresh, destroy)
- ✅ Concurrent authentication request handling (prevents race conditions)
- ✅ Token expiration detection and automatic refresh
- ✅ Error handling and recovery scenarios (all error types covered)
- ✅ Storage operations with mock persistence and quota simulation
- ✅ Component messaging with mock communication
- ✅ Authentication state transitions
- ✅ Configuration validation and environment detection
- ✅ Mock scenario testing (success, failures, timeouts, corruption)

#### Phase 1B: Browser Integration (1 week)
**Goal**: Integrate AuthManager with actual Firefox extension APIs

**Tasks**:
- Implement browser-specific storage adapter using `browser.storage.local`
- Create browser messaging adapter using `browser.runtime.onMessage`
- Add browser timer integration using `browser.alarms`
- Integrate AuthManager into background.js
- Create real ServerAPI class for FastAPI communication
- Test with actual browser extension environment

**Deliverables**:
- Browser API adapter implementations
- Integrated background script with AuthManager
- Real server communication layer
- Browser environment testing setup

**Tests**:
- Session storage persistence across browser restarts
- Auth state retrieval by popup components
- Real browser messaging between components
- Actual server communication testing

### Phase 2: API Request Wrapper
**Goal**: Create unified API client for all authenticated requests

**Tasks**:
- Create `AuthenticatedAPI` class
- Implement request interceptor to add auth headers
- Add automatic re-authentication on token expiration
- Create helper methods for common API calls

**Deliverables**:
- Unified API client class
- Request/response interceptors
- Error handling middleware

**Tests**:
- Automatic session_id injection
- Token refresh on expiration
- Graceful handling of auth failures

### Phase 3: Plugin Component Integration
**Goal**: Update all plugin components to use authenticated API

**Tasks**:
- Update recorder.js to use AuthenticatedAPI
- Modify upload-and-transcribe-mp3 calls to include session_id
- Add auth status indicators to UI
- Handle authentication prompts in user flow

**Deliverables**:
- Updated recorder component
- Auth status UI elements
- User authentication prompts

**Tests**:
- End-to-end recording with authentication
- Agent mode requests with proper websocket_id
- UI state changes on auth status

### Phase 4: Server-Side Integration
**Goal**: Update FastAPI endpoints to properly handle plugin authentication

**Tasks**:
- Modify `/api/upload-and-transcribe-mp3` to accept session_id parameter
- Update TodoFifoQueue.push_job() calls to use provided session_id
- Add authentication middleware for plugin requests
- Implement session validation and cleanup

**Deliverables**:
- Updated FastAPI endpoints
- Session-aware queue processing
- Plugin-specific auth middleware

**Tests**:
- Agent requests properly queued with session tracking
- Session validation on API calls
- Proper WebSocket routing for plugin sessions

## Testing Strategy

### Pure JavaScript Testing (Phase 1A)

**Testing Framework**: Jest with Node.js environment
- **Coverage Target**: 80%+ for all core authentication logic
- **Mock Strategy**: Complete mock implementations for all browser APIs
- **CI Integration**: Automated testing pipeline for continuous validation

**Core Logic Tests**:
- Session lifecycle management (create, validate, refresh, destroy)
- Authentication state transitions and consistency
- Token expiration detection and automatic refresh
- Concurrent authentication request prevention
- Error handling and recovery scenarios
- Storage operations with persistence simulation
- Component messaging protocol validation

**Mock Integration Tests**:
- AuthManager with MockStorage integration
- Component communication via MockMessaging
- Server API interaction via MockServerAPI
- Timer-based operations via MockTimer
- Authentication flow end-to-end with mocks

**Test Structure**:
```javascript
// Example test approach
describe('AuthManager', () => {
    let authManager, mockStorage, mockMessaging, mockAPI;
    
    beforeEach(() => {
        mockStorage = new MockStorage();
        mockMessaging = new MockMessaging();
        mockAPI = new MockServerAPI();
        
        authManager = new AuthManager({
            storage: mockStorage,
            messaging: mockMessaging,
            api: mockAPI
        });
    });
    
    test('prevents concurrent authentication requests', async () => {
        const promise1 = authManager.authenticate();
        const promise2 = authManager.authenticate();
        
        const [result1, result2] = await Promise.all([promise1, promise2]);
        expect(result1).toBe(result2); // Same session object
        expect(mockAPI.callCount('/api/get-session-id')).toBe(1);
    });
});
```

### Browser Environment Testing (Phase 1B)

**Integration Tests**:
- Real browser storage persistence across restarts
- Actual inter-component messaging
- WebExtension API compatibility
- Extension lifecycle events

**End-to-End Tests**:
- Complete authentication flow in browser
- Component coordination in real extension environment
- Server communication with actual FastAPI
- User workflow validation

### Plugin-Server Integration Tests (Phase 4)

**System Integration**:
- End-to-end authentication flow
- Agent mode request processing with queue tracking
- WebSocket session routing
- Error handling across plugin and server

**Performance Tests**:
- Authentication latency measurement
- Concurrent user handling
- Memory usage during extended sessions
- Storage efficiency and cleanup

### User Acceptance Tests

**Recording Workflow**:
- First-time user authentication experience
- Seamless recording after authentication
- Agent mode command processing
- Error recovery and user feedback

**Session Management**:
- Browser restart persistence validation
- Token expiration handling with user notification
- Manual re-authentication flow
- Multiple tab coordination and consistency

## Security Considerations

### Token Storage
- Use `browser.storage.local` for persistence
- Consider encryption for sensitive tokens
- Implement secure token refresh mechanism
- Clear tokens on extension uninstall

### Request Security
- Always use HTTPS for authentication requests
- Validate server certificates
- Implement request timeout and retry limits
- Log security events for debugging

### User Privacy
- Minimize stored user data
- Implement session cleanup on logout
- Respect user's authentication preferences
- Provide clear auth status indicators

## Error Handling & User Experience

### Graceful Degradation
- **No Auth**: Show transcription-only mode
- **Server Down**: Cache requests for retry
- **Token Expired**: Seamless re-authentication
- **Network Issues**: Clear error messages

### User Feedback
- **Auth Status**: Visual indicators in popup/sidebar
- **Progress**: Loading states during authentication
- **Errors**: Clear, actionable error messages
- **Success**: Confirmation of successful authentication

### Accessibility
- Screen reader compatible auth prompts
- Keyboard navigation for auth flows
- High contrast auth status indicators
- Timeout warnings for user action

## Dependencies & Coordination

### Server-Side Changes Required
- Session ID parameter support in audio endpoints
- Authentication middleware for plugin requests
- WebSocket session routing updates
- Queue system session tracking

### Plugin Architecture Updates
- Background script messaging system
- Component communication protocols
- Storage schema definitions
- UI component updates

### Testing Infrastructure
- Mock authentication server
- Automated browser testing
- Cross-component test helpers
- Performance testing tools

## Timeline Estimates

- **Phase 1**: 1-2 weeks (Background auth manager)
- **Phase 2**: 1 week (API wrapper)
- **Phase 3**: 1-2 weeks (Component integration)
- **Phase 4**: 1 week (Server integration)
- **Testing & Refinement**: 1 week

**Total Estimated Duration**: 5-7 weeks

## Success Criteria

1. **Seamless User Experience**: Users can record and use agent mode without explicit auth steps
2. **Reliable Session Management**: Auth state persists across browser sessions and component lifecycle
3. **Proper Queue Integration**: Agent requests properly tracked with WebSocket sessions
4. **Robust Error Handling**: Clear feedback and recovery for all authentication scenarios
5. **Performance**: No noticeable latency added to recording workflow

---

**Next Steps**: Create implementation tracking document and begin Phase 1 development.